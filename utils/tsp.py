"""
TSP class implemented as a proxy of the shared object class; this file contains the aforementioned class and its
implementation

Camilo RamÃ­rez C. - FCFM - Universidad de Chile
"""
from utils.util_functions import add_tsp_path

import numpy as np
import os

# Path for the TSP shared object
tsp_path: str = os.path.join(os.path.dirname(p=__file__), "../src")
add_tsp_path(tsp_path=tsp_path)

# Import of the shared object
from TSP import TSP as TSP_


class TSP:
    """
    TSP class, this class serves as a proxy for the shared object generated by the compilation of the C++ implemented
    class, this is meant only for nice documentation and type-hinting.

    Attributes
    ----------
    tsp: tsp
        Shared object compiled from the C++ source code of the TSP
    is_grown: bool
        Boolean that indicates if the tree that defines the TSP has been grown or not
    is_regularized: bool
        Boolean that indicates if the tree that defines the TSP has been regularized or not
    """
    def __init__(self, l_bn: float = 0.167, w_bn: float = 5e-2, lambda_factor: float = 2.3e-5) -> None:
        """
        TSP object constructor

        Parameters
        ----------
        l_bn: float
            Exponent of the TSP cells refinement threshold, note that bn = w_bn * n**l_bn, this value must be in the
            interval (0, 1/3)
        w_bn: float
            Weighting factor of the TSP cells refinement threshold, note that bn = w_bn * n**l_bn
        lambda_factor: float
            Regularization factor for the tree structured partitions

        Raises
        ------
        ValueError
            If l_bn does not belong to the interval (0, 1/3)
        """
        if not 0 < l_bn < 1/3:
            raise ValueError("l_bn value must belong to the interval (0, 1/3)")
        self.tsp: TSP = TSP_(l_bn, w_bn, lambda_factor)
        self.is_grown: bool = False
        self.is_regularized: bool = False

    def grow(self, x: np.ndarray, y: np.ndarray) -> None:
        """
        Method that triggers the growing phase of the TSP method considering the samples X and Y of the joint
        distribution components in which its mutual information it's going to be estimated, these arrays must be on
        Fortran order

        Parameters
        ----------
        x: np.ndarray
            Samples of X
        y: np.ndarray
            Samples of Y

        Raises
        ------
        ValueError
            If the sample arrays are not in Fortran order
        """
        if not x.flags.f_contiguous:
            if not y.flags.f_contiguous:
                raise ValueError("The arrays x and y must be on Fortran order")
            raise ValueError("The array x must be in Fortran order")
        elif not y.flags.f_contiguous:
            raise ValueError("The array y must be in Fortran order")
        self.tsp.grow(x, y)
        self.is_grown = True

    def regularize(self) -> None:
        """
        Method that regularizes the complexity of the partition that defines the tree structured partition

        Raises
        ------
        RuntimeError
            If the TSP has not been grown previously
        """
        if not self.is_grown:
            raise RuntimeError("The TSP object must have been grown before regularization")
        self.tsp.regularize()
        self.is_regularized = True

    def size(self) -> int:
        """
        Gets the size of the tree that defines the TSP

        Raises
        ------
        RuntimeError
            If the TSP has not been grown previously

        Returns
        -------
        int
            The size of the tree that defines the TSP
        """
        if not self.is_grown:
            raise RuntimeError("The TSP object must have been grown before obtaining its size")
        return self.tsp.size()
    
    def reg_size(self) -> int:
        """
        Gets the regularized size of the tree that defines the TSP

        Raises
        ------
        RuntimeError
            If the TSP has not been grown previously

        Returns
        -------
        int
            The size of the tree that defines the TSP
        """
        if not self.is_grown:
            raise RuntimeError("The TSP object must have been grown before obtaining its size")
        return self.tsp.reg_size()

    def emi(self) -> float:
        """
        Gets the mutual information estimation given by the TSP

        Raises
        ------
        RuntimeError
            If the tree that defines the TSP has not been grown previously

        Returns
        -------
        float
            The estimated mutual information between X and Y
        """
        if not self.is_grown:
            raise RuntimeError("The TSP object must have been grown before obtaining any estimation of the mutual "
                               "information")
        return self.tsp.emi()

    def reg_emi(self) -> float:
        """
        Gets the regularized mutual information given by the TSP, this is only possible after the tree regularization

        Raises
        ------
        RuntimeError
            If the tree that defines the TSP has not been pruned (TSP regularization) previously

        Returns
        -------
        float
            The regularized estimated mutual information between X and Y
        """
        if not self.is_regularized:
            raise RuntimeError("The TSP object must have been regularized before obtaining the regularized estimation "
                               "of the mutual information")
        return self.tsp.reg_emi()
